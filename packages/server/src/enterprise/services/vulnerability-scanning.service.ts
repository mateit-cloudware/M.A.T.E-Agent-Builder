/**
 * M.A.T.E. Vulnerability Scanning Service (S3.2c)
 * 
 * Automatisierte Schwachstellenerkennung für SOC 2 Compliance:
 * - Dependency Scanning (npm audit, outdated packages)
 * - Security Header Analysis
 * - Configuration Vulnerability Check
 * - API Security Assessment
 */

import * as crypto from 'crypto'
import { DataSource } from 'typeorm'
import { Entity, Column, PrimaryColumn, CreateDateColumn, Index } from 'typeorm'
import { v4 as uuidv4 } from 'uuid'

// ==================== Vulnerability Entity ====================

export enum VulnerabilitySeverity {
    CRITICAL = 'critical',
    HIGH = 'high',
    MEDIUM = 'medium',
    LOW = 'low',
    INFO = 'info'
}

export enum VulnerabilityStatus {
    OPEN = 'open',
    IN_PROGRESS = 'in_progress',
    RESOLVED = 'resolved',
    ACCEPTED = 'accepted',
    FALSE_POSITIVE = 'false_positive'
}

export enum ScanType {
    DEPENDENCY = 'dependency',
    SECURITY_HEADERS = 'security_headers',
    CONFIGURATION = 'configuration',
    API_SECURITY = 'api_security',
    CODE_ANALYSIS = 'code_analysis',
    INFRASTRUCTURE = 'infrastructure'
}

@Entity('mate_vulnerability_findings')
export class VulnerabilityFinding {
    @PrimaryColumn('uuid')
    id: string = uuidv4()

    @Column({ name: 'scan_id', type: 'uuid' })
    @Index()
    scanId: string = ''

    @Column({ name: 'scan_type', type: 'varchar', length: 50 })
    scanType: ScanType = ScanType.DEPENDENCY

    @Column({ type: 'varchar', length: 50 })
    @Index()
    severity: VulnerabilitySeverity = VulnerabilitySeverity.INFO

    @Column({ type: 'varchar', length: 50, default: 'open' })
    @Index()
    status: VulnerabilityStatus = VulnerabilityStatus.OPEN

    @Column({ type: 'varchar', length: 255 })
    title: string = ''

    @Column({ type: 'text' })
    description: string = ''

    @Column({ type: 'varchar', length: 500, nullable: true })
    affectedComponent?: string

    @Column({ name: 'cve_id', type: 'varchar', length: 50, nullable: true })
    cveId?: string

    @Column({ name: 'cwe_id', type: 'varchar', length: 50, nullable: true })
    cweId?: string

    @Column({ type: 'text', nullable: true })
    recommendation?: string

    @Column({ type: 'simple-json', nullable: true })
    references?: string[]

    @Column({ name: 'cvss_score', type: 'float', nullable: true })
    cvssScore?: number

    @Column({ name: 'resolved_at', type: 'timestamp', nullable: true })
    resolvedAt?: Date

    @Column({ name: 'resolved_by', type: 'uuid', nullable: true })
    resolvedBy?: string

    @Column({ name: 'resolution_notes', type: 'text', nullable: true })
    resolutionNotes?: string

    @CreateDateColumn({ name: 'discovered_at' })
    discoveredAt: Date = new Date()
}

@Entity('mate_vulnerability_scans')
export class VulnerabilityScan {
    @PrimaryColumn('uuid')
    id: string = uuidv4()

    @Column({ name: 'scan_type', type: 'varchar', length: 50 })
    scanType: ScanType = ScanType.DEPENDENCY

    @Column({ type: 'varchar', length: 50, default: 'running' })
    status: 'running' | 'completed' | 'failed' = 'running'

    @Column({ name: 'findings_count', type: 'int', default: 0 })
    findingsCount: number = 0

    @Column({ name: 'critical_count', type: 'int', default: 0 })
    criticalCount: number = 0

    @Column({ name: 'high_count', type: 'int', default: 0 })
    highCount: number = 0

    @Column({ name: 'medium_count', type: 'int', default: 0 })
    mediumCount: number = 0

    @Column({ name: 'low_count', type: 'int', default: 0 })
    lowCount: number = 0

    @Column({ name: 'initiated_by', type: 'uuid', nullable: true })
    initiatedBy?: string

    @Column({ name: 'duration_ms', type: 'int', nullable: true })
    durationMs?: number

    @Column({ type: 'text', nullable: true })
    summary?: string

    @CreateDateColumn({ name: 'started_at' })
    startedAt: Date = new Date()

    @Column({ name: 'completed_at', type: 'timestamp', nullable: true })
    completedAt?: Date
}

// ==================== Interfaces ====================

export interface ScanResult {
    scanId: string
    scanType: ScanType
    findings: VulnerabilityFinding[]
    summary: ScanSummary
}

export interface ScanSummary {
    totalFindings: number
    critical: number
    high: number
    medium: number
    low: number
    info: number
    duration: number
}

export interface SecurityHeader {
    name: string
    expected: string | boolean
    found: string | boolean | null
    compliant: boolean
    severity: VulnerabilitySeverity
}

// ==================== Vulnerability Scanning Service ====================

class VulnerabilityScanningService {
    private dataSource: DataSource | null = null
    
    // In-Memory Storage (für Development)
    private scans: Map<string, VulnerabilityScan> = new Map()
    private findings: Map<string, VulnerabilityFinding[]> = new Map()

    // ==================== INITIALIZATION ====================

    public initialize(dataSource: DataSource): void {
        this.dataSource = dataSource
        console.log('[VulnScan] Service initialisiert')
    }

    // ==================== DEPENDENCY SCANNING ====================

    /**
     * Scannt npm-Abhängigkeiten auf bekannte Schwachstellen
     */
    public async scanDependencies(): Promise<ScanResult> {
        const scan = await this.createScan(ScanType.DEPENDENCY)
        const scanFindings: VulnerabilityFinding[] = []

        try {
            // Simulierte Dependency-Prüfung (in Produktion: npm audit --json)
            const vulnerableDeps = await this.checkNpmVulnerabilities()

            for (const dep of vulnerableDeps) {
                const finding = new VulnerabilityFinding()
                finding.id = uuidv4()
                finding.scanId = scan.id
                finding.scanType = ScanType.DEPENDENCY
                finding.severity = dep.severity
                finding.title = `Vulnerable dependency: ${dep.name}@${dep.version}`
                finding.description = dep.description
                finding.affectedComponent = `${dep.name}@${dep.version}`
                finding.cveId = dep.cveId
                finding.recommendation = dep.recommendation
                finding.references = dep.references

                scanFindings.push(finding)
            }

            // Veraltete Pakete prüfen
            const outdatedFindings = await this.checkOutdatedPackages()
            scanFindings.push(...outdatedFindings.map(f => ({ ...f, scanId: scan.id })))

            await this.completeScan(scan, scanFindings)

            return {
                scanId: scan.id,
                scanType: ScanType.DEPENDENCY,
                findings: scanFindings,
                summary: this.calculateSummary(scanFindings, scan.durationMs || 0)
            }
        } catch (error) {
            await this.failScan(scan, error)
            throw error
        }
    }

    private async checkNpmVulnerabilities(): Promise<Array<{
        name: string
        version: string
        severity: VulnerabilitySeverity
        description: string
        cveId?: string
        recommendation: string
        references: string[]
    }>> {
        // In Produktion: `npm audit --json` ausführen und parsen
        // Hier: Beispieldaten für Demonstration

        return [
            // Keine bekannten Schwachstellen bei sauberem Projekt
        ]
    }

    private async checkOutdatedPackages(): Promise<VulnerabilityFinding[]> {
        // In Produktion: `npm outdated --json` ausführen
        // Hier: Beispiel-Check

        const findings: VulnerabilityFinding[] = []

        // Prüfe kritische Pakete auf Updates
        const criticalPackages = [
            'express',
            'typeorm',
            'jsonwebtoken',
            'bcryptjs'
        ]

        // In Produktion würde hier npm outdated gecheckt
        return findings
    }

    // ==================== SECURITY HEADERS SCANNING ====================

    /**
     * Prüft Security-Headers der Anwendung
     */
    public async scanSecurityHeaders(targetUrl?: string): Promise<ScanResult> {
        const scan = await this.createScan(ScanType.SECURITY_HEADERS)
        const scanFindings: VulnerabilityFinding[] = []

        try {
            const expectedHeaders: SecurityHeader[] = [
                {
                    name: 'Strict-Transport-Security',
                    expected: 'max-age=31536000; includeSubDomains',
                    found: null,
                    compliant: false,
                    severity: VulnerabilitySeverity.HIGH
                },
                {
                    name: 'Content-Security-Policy',
                    expected: true,
                    found: null,
                    compliant: false,
                    severity: VulnerabilitySeverity.MEDIUM
                },
                {
                    name: 'X-Content-Type-Options',
                    expected: 'nosniff',
                    found: null,
                    compliant: false,
                    severity: VulnerabilitySeverity.MEDIUM
                },
                {
                    name: 'X-Frame-Options',
                    expected: 'DENY',
                    found: null,
                    compliant: false,
                    severity: VulnerabilitySeverity.MEDIUM
                },
                {
                    name: 'X-XSS-Protection',
                    expected: '1; mode=block',
                    found: null,
                    compliant: false,
                    severity: VulnerabilitySeverity.LOW
                },
                {
                    name: 'Referrer-Policy',
                    expected: 'strict-origin-when-cross-origin',
                    found: null,
                    compliant: false,
                    severity: VulnerabilitySeverity.LOW
                },
                {
                    name: 'Permissions-Policy',
                    expected: true,
                    found: null,
                    compliant: false,
                    severity: VulnerabilitySeverity.LOW
                }
            ]

            // In Produktion: HTTP-Request an targetUrl senden und Headers prüfen
            // Hier: Dokumentation der erwarteten Konfiguration

            for (const header of expectedHeaders) {
                if (!header.compliant) {
                    const finding = new VulnerabilityFinding()
                    finding.id = uuidv4()
                    finding.scanId = scan.id
                    finding.scanType = ScanType.SECURITY_HEADERS
                    finding.severity = header.severity
                    finding.title = `Missing or misconfigured header: ${header.name}`
                    finding.description = `The security header ${header.name} is missing or not properly configured.`
                    finding.affectedComponent = 'HTTP Response Headers'
                    finding.cweId = 'CWE-693'
                    finding.recommendation = `Add header: ${header.name}: ${header.expected}`
                    finding.references = ['https://owasp.org/www-project-secure-headers/']

                    scanFindings.push(finding)
                }
            }

            await this.completeScan(scan, scanFindings)

            return {
                scanId: scan.id,
                scanType: ScanType.SECURITY_HEADERS,
                findings: scanFindings,
                summary: this.calculateSummary(scanFindings, scan.durationMs || 0)
            }
        } catch (error) {
            await this.failScan(scan, error)
            throw error
        }
    }

    // ==================== CONFIGURATION SCANNING ====================

    /**
     * Prüft Konfigurationsschwachstellen
     */
    public async scanConfiguration(): Promise<ScanResult> {
        const scan = await this.createScan(ScanType.CONFIGURATION)
        const scanFindings: VulnerabilityFinding[] = []

        try {
            // Umgebungsvariablen prüfen
            scanFindings.push(...this.checkEnvironmentVariables(scan.id))

            // Datenbank-Konfiguration prüfen
            scanFindings.push(...this.checkDatabaseConfig(scan.id))

            // JWT-Konfiguration prüfen
            scanFindings.push(...this.checkJWTConfig(scan.id))

            // Verschlüsselung prüfen
            scanFindings.push(...this.checkEncryptionConfig(scan.id))

            await this.completeScan(scan, scanFindings)

            return {
                scanId: scan.id,
                scanType: ScanType.CONFIGURATION,
                findings: scanFindings,
                summary: this.calculateSummary(scanFindings, scan.durationMs || 0)
            }
        } catch (error) {
            await this.failScan(scan, error)
            throw error
        }
    }

    private checkEnvironmentVariables(scanId: string): VulnerabilityFinding[] {
        const findings: VulnerabilityFinding[] = []

        const requiredVars = [
            { name: 'ENCRYPTION_KEY', severity: VulnerabilitySeverity.CRITICAL },
            { name: 'JWT_SECRET', severity: VulnerabilitySeverity.CRITICAL },
            { name: 'DATABASE_URL', severity: VulnerabilitySeverity.HIGH }
        ]

        for (const envVar of requiredVars) {
            const value = process.env[envVar.name]
            
            if (!value) {
                const finding = new VulnerabilityFinding()
                finding.id = uuidv4()
                finding.scanId = scanId
                finding.scanType = ScanType.CONFIGURATION
                finding.severity = envVar.severity
                finding.title = `Missing environment variable: ${envVar.name}`
                finding.description = `Critical security environment variable ${envVar.name} is not set.`
                finding.affectedComponent = 'Environment Configuration'
                finding.cweId = 'CWE-260'
                finding.recommendation = `Set ${envVar.name} environment variable with a strong, random value.`
                findings.push(finding)
            }
        }

        // Prüfe auf schwache Secrets
        const jwtSecret = process.env['JWT_SECRET'] || ''
        if (jwtSecret && jwtSecret.length < 32) {
            const finding = new VulnerabilityFinding()
            finding.id = uuidv4()
            finding.scanId = scanId
            finding.scanType = ScanType.CONFIGURATION
            finding.severity = VulnerabilitySeverity.HIGH
            finding.title = 'Weak JWT secret'
            finding.description = 'JWT_SECRET is too short (< 32 characters). This weakens authentication security.'
            finding.affectedComponent = 'JWT Configuration'
            finding.cweId = 'CWE-326'
            finding.recommendation = 'Use a JWT secret with at least 256 bits (32+ characters) of entropy.'
            findings.push(finding)
        }

        return findings
    }

    private checkDatabaseConfig(scanId: string): VulnerabilityFinding[] {
        const findings: VulnerabilityFinding[] = []

        const dbUrl = process.env['DATABASE_URL'] || ''

        // Prüfe auf unsichere Datenbank-Verbindung
        if (dbUrl && !dbUrl.includes('sslmode=require') && !dbUrl.includes('ssl=true')) {
            const finding = new VulnerabilityFinding()
            finding.id = uuidv4()
            finding.scanId = scanId
            finding.scanType = ScanType.CONFIGURATION
            finding.severity = VulnerabilitySeverity.MEDIUM
            finding.title = 'Database connection without SSL'
            finding.description = 'Database connection string does not enforce SSL/TLS encryption.'
            finding.affectedComponent = 'Database Configuration'
            finding.cweId = 'CWE-319'
            finding.recommendation = 'Add sslmode=require or ssl=true to your database connection string.'
            findings.push(finding)
        }

        return findings
    }

    private checkJWTConfig(scanId: string): VulnerabilityFinding[] {
        const findings: VulnerabilityFinding[] = []

        // Prüfe Token-Ablaufzeit (sollte konfiguriert sein)
        const tokenExpiry = process.env['JWT_TOKEN_EXPIRY']
        if (!tokenExpiry) {
            const finding = new VulnerabilityFinding()
            finding.id = uuidv4()
            finding.scanId = scanId
            finding.scanType = ScanType.CONFIGURATION
            finding.severity = VulnerabilitySeverity.LOW
            finding.title = 'JWT token expiry not explicitly configured'
            finding.description = 'JWT_TOKEN_EXPIRY is not set. Tokens may have default or no expiration.'
            finding.affectedComponent = 'JWT Configuration'
            finding.recommendation = 'Set JWT_TOKEN_EXPIRY to a reasonable value (e.g., 1h for access tokens).'
            findings.push(finding)
        }

        return findings
    }

    private checkEncryptionConfig(scanId: string): VulnerabilityFinding[] {
        const findings: VulnerabilityFinding[] = []

        const encKey = process.env['ENCRYPTION_KEY'] || ''

        // Prüfe Schlüssellänge (sollte 64 Hex-Zeichen = 256 Bit sein)
        if (encKey && encKey.length < 64) {
            const finding = new VulnerabilityFinding()
            finding.id = uuidv4()
            finding.scanId = scanId
            finding.scanType = ScanType.CONFIGURATION
            finding.severity = VulnerabilitySeverity.HIGH
            finding.title = 'Encryption key too short'
            finding.description = 'ENCRYPTION_KEY should be 256 bits (64 hex characters) for AES-256.'
            finding.affectedComponent = 'Encryption Configuration'
            finding.cweId = 'CWE-326'
            finding.recommendation = 'Generate a proper key: openssl rand -hex 32'
            findings.push(finding)
        }

        return findings
    }

    // ==================== API SECURITY SCANNING ====================

    /**
     * Prüft API-Sicherheit
     */
    public async scanAPISecurity(): Promise<ScanResult> {
        const scan = await this.createScan(ScanType.API_SECURITY)
        const scanFindings: VulnerabilityFinding[] = []

        try {
            // Rate Limiting prüfen
            if (!process.env['RATE_LIMIT_ENABLED'] || process.env['RATE_LIMIT_ENABLED'] !== 'true') {
                const finding = new VulnerabilityFinding()
                finding.id = uuidv4()
                finding.scanId = scan.id
                finding.scanType = ScanType.API_SECURITY
                finding.severity = VulnerabilitySeverity.MEDIUM
                finding.title = 'Rate limiting not configured'
                finding.description = 'API rate limiting is not explicitly enabled.'
                finding.affectedComponent = 'API Gateway'
                finding.cweId = 'CWE-770'
                finding.recommendation = 'Enable rate limiting to prevent denial-of-service attacks.'
                scanFindings.push(finding)
            }

            // CORS-Konfiguration prüfen
            const corsOrigins = process.env['CORS_ORIGINS'] || ''
            if (corsOrigins === '*') {
                const finding = new VulnerabilityFinding()
                finding.id = uuidv4()
                finding.scanId = scan.id
                finding.scanType = ScanType.API_SECURITY
                finding.severity = VulnerabilitySeverity.MEDIUM
                finding.title = 'Overly permissive CORS configuration'
                finding.description = 'CORS is configured to allow all origins (*), which may expose the API to cross-origin attacks.'
                finding.affectedComponent = 'CORS Configuration'
                finding.cweId = 'CWE-942'
                finding.recommendation = 'Restrict CORS to specific trusted domains.'
                scanFindings.push(finding)
            }

            await this.completeScan(scan, scanFindings)

            return {
                scanId: scan.id,
                scanType: ScanType.API_SECURITY,
                findings: scanFindings,
                summary: this.calculateSummary(scanFindings, scan.durationMs || 0)
            }
        } catch (error) {
            await this.failScan(scan, error)
            throw error
        }
    }

    // ==================== FULL SCAN ====================

    /**
     * Führt alle Scans durch
     */
    public async runFullScan(): Promise<{
        scans: ScanResult[]
        overallSummary: ScanSummary
    }> {
        const scans: ScanResult[] = []

        console.log('[VulnScan] Starting full vulnerability scan...')

        // Dependency Scan
        try {
            scans.push(await this.scanDependencies())
        } catch (error) {
            console.error('[VulnScan] Dependency scan failed:', error)
        }

        // Security Headers Scan
        try {
            scans.push(await this.scanSecurityHeaders())
        } catch (error) {
            console.error('[VulnScan] Security headers scan failed:', error)
        }

        // Configuration Scan
        try {
            scans.push(await this.scanConfiguration())
        } catch (error) {
            console.error('[VulnScan] Configuration scan failed:', error)
        }

        // API Security Scan
        try {
            scans.push(await this.scanAPISecurity())
        } catch (error) {
            console.error('[VulnScan] API security scan failed:', error)
        }

        // Gesamtübersicht berechnen
        const allFindings = scans.flatMap(s => s.findings)
        const totalDuration = scans.reduce((sum, s) => sum + s.summary.duration, 0)

        console.log(`[VulnScan] Full scan completed. ${allFindings.length} findings.`)

        return {
            scans,
            overallSummary: this.calculateSummary(allFindings, totalDuration)
        }
    }

    // ==================== SCAN MANAGEMENT ====================

    private async createScan(scanType: ScanType): Promise<VulnerabilityScan> {
        const scan = new VulnerabilityScan()
        scan.id = uuidv4()
        scan.scanType = scanType
        scan.status = 'running'
        scan.startedAt = new Date()

        this.scans.set(scan.id, scan)
        return scan
    }

    private async completeScan(scan: VulnerabilityScan, findings: VulnerabilityFinding[]): Promise<void> {
        scan.completedAt = new Date()
        scan.durationMs = scan.completedAt.getTime() - scan.startedAt.getTime()
        scan.status = 'completed'
        scan.findingsCount = findings.length
        scan.criticalCount = findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL).length
        scan.highCount = findings.filter(f => f.severity === VulnerabilitySeverity.HIGH).length
        scan.mediumCount = findings.filter(f => f.severity === VulnerabilitySeverity.MEDIUM).length
        scan.lowCount = findings.filter(f => f.severity === VulnerabilitySeverity.LOW).length

        this.scans.set(scan.id, scan)
        this.findings.set(scan.id, findings)
    }

    private async failScan(scan: VulnerabilityScan, error: unknown): Promise<void> {
        scan.completedAt = new Date()
        scan.durationMs = scan.completedAt.getTime() - scan.startedAt.getTime()
        scan.status = 'failed'
        scan.summary = error instanceof Error ? error.message : 'Unknown error'

        this.scans.set(scan.id, scan)
    }

    private calculateSummary(findings: VulnerabilityFinding[], duration: number): ScanSummary {
        return {
            totalFindings: findings.length,
            critical: findings.filter(f => f.severity === VulnerabilitySeverity.CRITICAL).length,
            high: findings.filter(f => f.severity === VulnerabilitySeverity.HIGH).length,
            medium: findings.filter(f => f.severity === VulnerabilitySeverity.MEDIUM).length,
            low: findings.filter(f => f.severity === VulnerabilitySeverity.LOW).length,
            info: findings.filter(f => f.severity === VulnerabilitySeverity.INFO).length,
            duration
        }
    }

    // ==================== FINDINGS MANAGEMENT ====================

    /**
     * Aktualisiert den Status eines Findings
     */
    public async updateFindingStatus(
        findingId: string,
        status: VulnerabilityStatus,
        resolvedBy?: string,
        notes?: string
    ): Promise<VulnerabilityFinding | null> {
        for (const [scanId, findingList] of this.findings.entries()) {
            const finding = findingList.find(f => f.id === findingId)
            if (finding) {
                finding.status = status
                if (status === VulnerabilityStatus.RESOLVED) {
                    finding.resolvedAt = new Date()
                    finding.resolvedBy = resolvedBy
                }
                finding.resolutionNotes = notes
                return finding
            }
        }
        return null
    }

    /**
     * Holt alle offenen Findings
     */
    public async getOpenFindings(): Promise<VulnerabilityFinding[]> {
        const allFindings: VulnerabilityFinding[] = []
        
        for (const findingList of this.findings.values()) {
            const open = findingList.filter(f => 
                f.status === VulnerabilityStatus.OPEN || 
                f.status === VulnerabilityStatus.IN_PROGRESS
            )
            allFindings.push(...open)
        }

        return allFindings.sort((a, b) => {
            const severityOrder = { critical: 0, high: 1, medium: 2, low: 3, info: 4 }
            return severityOrder[a.severity] - severityOrder[b.severity]
        })
    }

    /**
     * Generiert einen Vulnerability-Bericht
     */
    public async generateReport(): Promise<string> {
        const fullScan = await this.runFullScan()

        let report = `# M.A.T.E. Vulnerability Scan Report\n\n`
        report += `**Datum:** ${new Date().toISOString()}\n\n`
        report += `## Zusammenfassung\n\n`
        report += `| Kategorie | Anzahl |\n`
        report += `|-----------|--------|\n`
        report += `| Kritisch | ${fullScan.overallSummary.critical} |\n`
        report += `| Hoch | ${fullScan.overallSummary.high} |\n`
        report += `| Mittel | ${fullScan.overallSummary.medium} |\n`
        report += `| Niedrig | ${fullScan.overallSummary.low} |\n`
        report += `| Info | ${fullScan.overallSummary.info} |\n`
        report += `| **Gesamt** | **${fullScan.overallSummary.totalFindings}** |\n\n`

        for (const scan of fullScan.scans) {
            report += `## ${scan.scanType.toUpperCase()}\n\n`
            
            if (scan.findings.length === 0) {
                report += `Keine Schwachstellen gefunden.\n\n`
                continue
            }

            for (const finding of scan.findings) {
                report += `### ${finding.title}\n\n`
                report += `- **Severity:** ${finding.severity.toUpperCase()}\n`
                report += `- **Status:** ${finding.status}\n`
                if (finding.cveId) report += `- **CVE:** ${finding.cveId}\n`
                if (finding.cweId) report += `- **CWE:** ${finding.cweId}\n`
                report += `\n${finding.description}\n\n`
                if (finding.recommendation) {
                    report += `**Empfehlung:** ${finding.recommendation}\n\n`
                }
            }
        }

        return report
    }
}

// Singleton-Instanz
export const vulnerabilityScanningService = new VulnerabilityScanningService()
